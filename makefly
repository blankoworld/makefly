#!/usr/bin/lua

--[[

TODO:

  * Change process.lua to be into a lib named "blog" (for an example)
  * Export default variables from process.lua into a specific file. Example:

    config = {
      ext = .html
      index_name = index
    }

    Then:

    config = require 'config'
    print(config.ext)

  * QUIET mode
  * Display help in few languages

In main program:

  * Import gettext
  * Include default configuration variables
  * Check that makefly.rc configuration file exists. If not raise an error.
  * Read makefly.rc configuration file (with a ConfigParser that include it in a metatable)
  * Read args to see which one is asked
  * Launch the specific method regarding args

]]--

--[[ DEPENDANCIES ]]--

require 'lib.init'
local utils = require 'lib.utils'
require 'lib.rope'

--[[ VARIABLES ]]--
VERSION = '0.4-trunk'
local configfile = os.getenv('CONFIG') or currentpath .. '/config'
-- default display values
display_info =    _('  INFO   ')
display_success = _(' SUCCESS ')
display_enable =  _(' ENABLE  ')
display_disable = _(' DISABLE ')
display_warning = _(' WARNING ')
display_error =   _('  ERROR  ')

--[[ FUNCTIONS ]]--

local function error(message)
  print(message)
  os.exit(1)
end

local function clean(args)
  -- checks
  if config.template_extension == config.page_extension then
    error(string.format(_('[%s] You cannot choose an extension (%s) similar to template\'s one (%s).'), display_error, config.page_extension, config.template_extension))
  end
  -- cleaning
  local pubpath = currentpath .. '/' .. config.destdir
  local tmppath = currentpath .. '/' .. config.tmpdir
  if lfs.attributes(pubpath) ~= nil then
    utils.rm(pubpath)
    print(string.format(_('[%s] Removed: %s directory'), display_info, pubpath))
  else
    print(string.format(_('[%s] Missing: %s directory'), display_warning, pubpath))
  end
  if lfs.attributes(tmppath) ~= nil then
    utils.rm(tmppath)
    print(string.format(_('[%s] Removed: %s directory'), display_info, tmppath))
  else
    print(string.format(_('[%s] Missing: %s directory'), display_warning, tmppath))
  end
  local docpath = currentpath .. '/' .. config.docdir
  local docextension = string.gsub(config.page_extension, '\.(.*)', '%1')
  local docfiles = utils.listing(docpath, docextension)
  for _, filepath in pairs(docfiles) do
    os.remove(filepath)
  end
  print(string.format(_('[%s] Removed: %s/*%s files'), display_info, docpath, config.page_extension))
end

local function compile(args)
  print('compiling')
end

local function publish(args)
  local script = currentpath .. '/' .. config.toolsdir .. '/' .. config.publish_script
  local substitutions = {
    DESTDIR = currentpath .. '/' .. config.destdir,
    PUBLISH_DESTINATION = config.PUBLISH_DESTINATION
  }
  local ret = utils.launch_script(script, config.tmpdir, substitutions)
  if ret and ret > 0 then
    error(string.format(_('[%s] Publication failed!'), display_error))
  end
  print(string.format(_('[%s] Publish: %s content with %s'), display_success, config.destdir, script))
end

local function refresh(args)
  clean()
  compile()
end

local function add(args)
  local script = currentpath .. '/' .. config.toolsdir .. '/create_post.sh'
  local substitutions = {
    DBDIR = currentpath .. '/' .. config.dbdir,
    SRCDIR = currentpath .. '/' .. config.srcdir,
  }
  local user_choice = config.AUTO_EDIT
  local option = '-q'
  if user_choice and user_choice == 1 then
    option = ''
  end
  local ret = utils.launch_script(script, config.tmpdir, substitutions, option)
  if ret and ret > 0 then
    error(string.format(_('[%s] New post failed!'), display_error))
  end
  print(string.format(_('[%s] New post added successfully.'), display_success))
end

local function list(args, commands)
  -- convert commands to sequence
  local sorted_commands = { }
  for index, value in pairs(commands) do
    table.insert(sorted_commands, { index, value })
  end

  -- sort command
  table.sort(sorted_commands, function (a, b) return a[1] < b[1] end)

  -- making result
  local res = _('List of available commands: ')
  for _, command in pairs(sorted_commands) do
    res = res .. string.format('\n%s\t\t%s', command[1], command[2].description)
  end
  -- display result on screen
  print(res)
end

local function backup(args)
  utils.checkDirectory(currentpath .. '/' .. config.backupdir)
  -- create zipfile
  local today = os.date('%Y%m%d', os.time())
  local filepath = currentpath .. '/' .. config.backupdir .. '/' .. today .. '_makefly.tar' .. config.compression_extension
  local to_save = {
    config.staticdir,
    config.dbdir,
    config.srcdir,
    config.specialdir,
    config.tmpldir,
  }
  local command = 'tar cf - makefly.rc'
  for idx, dir in ipairs(to_save) do
    command = command .. ' ' .. dir
  end
  command = command .. string.format(_('| %s > %s'), config.compression_command, filepath)
  local ret = os.execute(command)
  if ret and ret == 0 then
    print(string.format(_('[%s] Backup: Files successfully saved in %s: makefly.rc, %s, %s, %s, %s and %s'), display_success, config.backupdir, config.staticdir, config.dbdir, config.srcdir, config.specialdir, config.tmpldir))
  else
    error(string.format(_('[%s] Backup failed!'), display_error))
  end
end

local function install(args)
  local origin = config.destdir
  local destination = config.INSTALLDIR
  -- replace only "$USER" variable in destination path
  destination = utils.replace(destination, { USER = os.getenv('USER') })
  if destination == nil then
    error(string.format(_('[%s] No INSTALLDIR found. Please add INSTALLDIR= in your makefly.rc'), display_error))
  end
  for idx, dir in pairs({origin, destination}) do
    if lfs.attributes(dir) == nil then
      error(string.format(_('[%s] %s directory not found!'), display_error, dir))
    end
  end
  print(string.format(_('This will delete %s content and copy all files from %s into this directory. Are you sure [y/n]?'), destination, origin))
  local answer = io.read()
  if answer == 'y' then
    -- first delete destination directory. Then create it and finally copy all files from origin to destination.
    utils.rm(destination)
    lfs.mkdir(destination)
    utils.copy(origin, destination)
    print(string.format(_('[%s] Installation: achieved.'), display_info))
  else
    print(string.format(_('[%s] Installation failed!'), display_warning))
  end
end

local function migratefrom(args)
  if #args < 2 then
    error(string.format(_('[%s] Migration: missing URL parameter.'), display_error))
  end
  local name = args[2]
  local script = currentpath .. '/' .. config.toolsdir .. '/migrate_domain_from.sh'
  local substitutions = {
    DBDIR = currentpath .. '/' .. config.dbdir,
  }
  local ret = utils.launch_script(script, config.tmpdir, substitutions, name)
  if ret and ret > 0 then
    error(string.format(_('[%s] Migration failed!'), display_error))
  end
  print(string.format(_('[%s] Migration achieved.'), display_success))
end

local function theme(args)
  -- check name
  if #args < 2 then
    error(string.format(_('[%s] Give a name.'), display_warning))
  end
  local name = args[2]
  -- check existing themes
  local directory = currentpath .. '/' .. config.tmpldir
  local dir_exists = utils.dir_exists(directory .. '/' .. name)
  if dir_exists then
    error(string.format(_('[%s] Theme already exists: %s'), display_error, name))
  end
  -- copy 'base' directory to the new one
  local basedir = directory .. '/base'
  if lfs.attributes(basedir) and lfs.attributes(basedir).mode == 'directory' then
    local destination = currentpath .. '/' .. config.tmpldir .. '/' .. name
    utils.copy(basedir, destination)
    -- read configuration file
    local configfile = destination .. '/config.mk'
    local newconfig = utils.getConfig(configfile)
    newconfig['CSS_NAME'] = name
    -- write result in config file
    local result = rope()
    for param, value in pairs(newconfig) do
      result:push(param .. ' = ' .. value .. '\n')
    end
    local out = assert(io.open(configfile, 'wb'))
    local content = result:flatten()
    out:write(content)
    assert(out:close())
  else
    error(string.format(_('[%s] Missing \'base\' directory'), display_error))
  end
  print(string.format(_('[%s] Created: New theme %s is available in \'%s\' directory.'), display_success, name, currentpath .. '/' .. config.tmpldir .. '/' .. name))
end

local function version(args)
  print(string.format(_('Makefly %s using %s'), VERSION, _VERSION))
end

local function doc(args)
  local directory = currentpath .. '/' .. config.docdir
  local header = utils.readFile(directory .. '/header.tmpl', 'r')
  local footer = utils.readFile(directory .. '/footer.tmpl', 'r')
  local version = string.format(_('Version %s'), VERSION)
  local tocreate = utils.listing(directory, 'md')
  local markdown = require 'markdown'
  for _, path in pairs(tocreate) do
    -- create content for final content
    local final = rope()
    final:push(header)
    final:push(version)
    local content = utils.readFile(path, 'r')
    final:push(markdown(content))
    final:push(footer)
    -- write result into a file
    local name = string.gsub(path, "(.*/)(.*)(\.md)", "%2")
    local filepath = directory .. '/' .. name .. config.page_extension
    local file = assert(io.open(filepath, 'wb'))
    file:write(final:flatten())
    assert(file:close())
  end
  print(string.format(_('[%s] Built: documentation files.'), display_info))
end

local function allowed(commands, command)
  res = false
  for v,_ in pairs(commands) do
    if v == command then
      res = true
      break
    end
  end
  return res
end

local function compilation()
  print("do compilation")
end

-- Create commands
local commands = { }
commands['clean'] = {
    description = _('clean up result directory'),
    launch = function (args) clean(args) end
  }
commands['list'] = {
    description = _('list all available commands'),
    launch = function (args) list(args, commands) end
  }
commands['publish'] = {
  description = _('publish your weblog using tools/publish.sh script'),
  launch = function (args) publish(args) end
}
commands['refresh'] = {
  description = _('same as clean + compile commands'),
  launch = function (args) refresh(args) end
}
commands['add'] = {
  description = _('create a new post'),
  launch = function (args) add(args) end
}
commands['help'] = {
  description = _('same as \'list\''),
  launch = function (args) list(args, commands) end
}
commands['createpost'] = {
  description = _('same as \'add\''),
  launch = function (args) add(args) end
}
commands['backup'] = {
  description = _('make a backup from your current makefly directory'),
  launch = function (args) backup(args) end
}
commands['install'] = {
  description = _('install \'pub\' directory into INSTALLDIR directory (set in makefly.rc file)'),
  launch = function (args) install(args) end
}
commands['migratefrom'] = {
  description = _('will update all DB files with given [url]'),
  launch = function (args) migratefrom(args) end
}
commands['theme'] = {
  description = _('will copy \'base\' theme to the new one given with [name]'),
  launch = function (args) theme(args) end
}
commands['version'] = {
  description = _('give current program version'),
  launch = function (args) version(args) end
}
commands['doc'] = {
  description = _('generate the documentation in \'doc\' directory'),
  launch = function (args) doc(args) end
}
commands['compile'] = {
  description = _('generate the weblog'),
  launch = function (args) compile(args) end
}

--[[ MAIN ]]--

-- check configuration files
local config_default = utils.checkConfig(configfile)
local config_user = utils.checkConfig(config_default.configurationfile)
config = utils.mergeConfig(config_default, config_user)
-- check command
local args = {...}
local command = args[1]
if command ~= nil then
  if allowed(commands, command) == true then
    -- launch user given command
    commands[command].launch(args)
  else
    print(string.format(_("'%s' option not found!"), command))
  end
else
  -- display list of commands by default
  list(args, commands)
end

return 0
